# resilient-design
App architecture design guide for resiliency - Retry, Fallback, Timeouts, Circuit Breakers

## 시작하기전에

본문의 내용은 마이크로소프트 애저 [WAF, Well-Architected Framework](https://docs.microsoft.com/en-us/azure/architecture/framework/)를 기반으로 하며 다음의 레퍼런스를 참조함. 

- [복원력 있는 애플리케이션 구현](https://docs.microsoft.com/ko-kr/dotnet/architecture/microservices/implement-resilient-applications/)
- [클라우드 응용프로그램의 모범사례](https://docs.microsoft.com/ko-kr/azure/architecture/best-practices/index-best-practices)

## 도입

소프트웨어 복원력의 주요 목표는 해당 범위 내에서 결함을 허용할 수 있는 최대한의 구성을 이루는것. 자동 장애복구 (failover) 또는 이중화와 같은 방식으로 구성요소의 내결함성을 구현, 최근에는 상식으로 받아들여지는 경향. 간단한 웹 애플리케이션에도 웹 서버, 데이터베이스, 방화벽, 프록시, 로드 밸런서 및 캐시 서버 등이 포함되고, 또한 네트워크 인프라는 너무 많은 구성 요소로 구성되어 항상 어딘가에서 오류가 발생함. 전체실패시나리오/SPoF 외에도 서비스 응답시간의 지체도 고려, 응답 형식이 정확하더라도 응답의 의미상의 오류를 발생하기도 함. 더 많은 구성 요소를 포함할 수록 실패 가능성은 상승함

### 가용성

가용성은 구성요소 서비스의 중요 품질속성으로 간주됨. 구성요소 서비스의 전체시간 대비 실제로 사용할 수 있는 시간으로 산정함

가용성 = 업타임 / (전체시간 = 업타임 + 다운타임)

전통적인 접근 방식은 업타임을 늘리는 것을 목표로 하는 반면 현대적인 접근 방식은 복구시간을 줄여 전체 다운타임을 줄이는 것을 목표로함

본문에서는 복구시간 제어 수간으로서 Retry, fallback, timeout 및 circuit breaker 의 네 가지 패턴을 설명함

## 패턴 

### Retry 

예상치 못한 응답(또는 요청에 응답없음)에 요청을 다시 전송하여 수정할 수 있다고 가정하면, 재시도 패턴을 사용하는 것이 도움됨. 작업이 실패로 표시되기 전에 실패한 경우 실패한 요청이 가능한 횟수만큼 재시도되는 매우 간단한 패턴

재시도는 다음과 같은 경우에 유용함

- 모든 종류의 가용성 문제 또는 connection (request) failure에 대해서 적용가능
- 패킷 손실과 같은 일시적인 네트워크 문제
- 대상 서비스의 내부 오류 (예: 데이터베이스 중단으로 인한)
- 대상 서비스에 대한 많은 요청으로 인해 응답이 없거나 느린 경우
- 그러나 대상 서비스에 과부하가 걸려 문제가 발생한 경우 재시도하면 문제가 더욱 악화될 수 있습니다. 복원 패턴이 서비스 거부 공격으로 바뀌는 것을 방지하기 위해서, 재시도 횟수, 간격을 제한하며, 다음 절에서 설명하는 Fallback, Circuit Breaker 등과 함께 적용

* Insert/Update/Delete가 포함된 DB쿼리시 주의. 단, 이경우에도 Auto Commit 으로 설정된 경우에는 무리없이 적용 가능함

### Fallback

대체 패턴을 사용하면 다른 서비스에 대한 요청이 실패한 경우 서비스가 계속 실행될 수 있습니다. 응답 누락으로 인해 계산을 중단하는 대신 대체 값을 채웁니다.

다음 애니메이션은 사기 수표 서비스에 요청을 발행하는 결제 서비스를 다시 보여줍니다. 다시 말하지만, 사기 수표 서비스는 내부 서버 오류를 반환합니다. 그러나 이번에는 거래가 사기가 아니라고 가정하는 대체가 있습니다.

https://res.cloudinary.com/practicaldev/image/fetch/s--MRhfRPLU--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/7oxihrr3n5k67h5h4szb.gif

대체 값이 항상 가능한 것은 아니지만 신중하게 사용하면 전반적인 복원력을 크게 높일 수 있습니다. 위의 예에서 사기 수표 서비스를 사용할 수 없는 경우 거래를 사기가 아닌 것으로 처리하는 것으로 대체하는 것은 위험할 수 있습니다. 심지어 서비스에 스팸을 먼저 보낸 다음 사기 거래를 하려고 시도하는 사기 거래에 대한 공격 표면을 엽니다.

반면에 모든 거래가 사기라고 가정하면 대체가 이루어지지 않으며 대체는 본질적으로 쓸모가 없습니다. 좋은 절충안은 단순한 비즈니스 규칙으로 대체하는 것입니다. 예를 들어 위험과 고객을 잃지 않는 것 사이에서 균형을 잘 잡기 위해 합리적으로 적은 양의 거래를 단순히 허용하는 것입니다.

### Timeouts

시간 초과 패턴은 매우 간단하며 많은 HTTP 클라이언트에는 기본 시간 초과가 구성되어 있습니다. 목표는 응답에 대한 무한한 대기 시간을 피하여 제한 시간 내에 응답이 수신되지 않은 모든 요청을 실패한 것으로 처리하는 것입니다.

아래 애니메이션은 결제 서비스가 사기 수표 서비스의 응답을 기다리고 제한 시간을 초과한 후 작업을 중단하는 것을 보여줍니다.

https://res.cloudinary.com/practicaldev/image/fetch/s--29ERQzjI--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/e0eetjip5m311u9ofpzr.gif

시간 초과는 요청이 영원히 멈추는 것을 방지하기 위해 거의 모든 애플리케이션에서 사용됩니다. 그러나 시간 초과를 처리하는 것은 쉬운 일이 아닙니다. 온라인 상점에서 주문 시간이 초과되었다고 상상해 보십시오. 주문이 성공적으로 접수되었는지 확신할 수 없지만 주문 생성이 아직 진행 중이거나 요청이 처리되지 않은 경우 응답 시간이 초과되었습니다. 시간 초과를 재시도와 결합하면 중복 주문이 발생할 수 있습니다. 주문을 실패로 표시하면 고객은 주문이 성공하지 못했다고 생각할 수 있지만 성공했을 수도 있고 청구될 것입니다.

또한 더 느린 응답이 도착할 수 있을 만큼 충분히 높지만 결코 도착하지 않을 응답을 기다리지 않을 만큼 충분히 낮은 시간 초과를 원합니다.

### Circuit breaker

전자 제품에서 회로 차단기는 과부하로 인한 손상으로부터 구성 요소를 보호하는 스위치입니다. 소프트웨어에서 회로 차단기는 높은 부하로 인해 이미 부분적으로 사용할 수 없는 동안 스팸이 발생하지 않도록 서비스를 보호합니다.

차단기  패턴 마틴 파울러하여 설명 하였다. 닫힘(요청이 자유롭게 흐를 수 있음), 열림(요청이 원격 리소스에 제출되지 않고 거부됨) 및 반개방(하나의 프로브 요청이 회로를 다시 닫으십시오). 아래 애니메이션은 작동 중인 회로 차단기를 보여줍니다.

https://res.cloudinary.com/practicaldev/image/fetch/s--27Vzd1lb--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/u3f6z484i74k0osz5r6z.gif


결제 서비스에서 사기 수표 서비스로의 요청은 회로 차단기를 통해 전달됩니다. 두 개의 내부 서버 오류가 발생한 후 회로가 열리고 후속 요청이 차단됩니다. 약간의 대기 시간 후에 회로는 반개방 상태가 됩니다. 이 상태에서는 하나의 요청을 통과하고 실패할 경우 열린 상태로 다시 변경하거나 성공할 경우 닫힌 상태로 변경할 수 있습니다. 다음 요청이 성공하여 회로가 다시 닫힙니다.

회로 차단기는 특히 재시도, 시간 초과 및 대체와 결합될 때 유용한 도구입니다. 폴백은 장애가 발생한 경우뿐만 아니라 회로가 열려 있는 경우에도 사용할 수 있습니다. 다음 섹션에서는 Kotlin으로 작성된 Vert.x의 코드 예제를 살펴보겠습니다.

## 정리하기

이 게시물에서 우리는 느슨한 결합, 격리, 대기 시간 제어 및 감독이 시스템 복원력에 긍정적인 영향을 미칠 수 있는 방법을 보았습니다. 재시도 패턴을 사용하면 여러 번 시도하여 수정할 수 있는 통신 오류를 처리할 수 있습니다. 대체 패턴은 로컬에서 통신 오류를 해결하는 데 도움이 됩니다. 시간 초과 패턴은 대기 시간의 상한을 제공합니다. 회로 차단기는 통신 오류가 지속되는 경우 재시도 및 빠른 폴백으로 인한 우발적인 서비스 거부 공격 문제를 해결합니다.

Vert.x와 같은 프레임워크는 기본적으로 몇 가지 복원 패턴을 제공합니다. 또한 모든 프레임워크와 함께 사용할 수 있는 전용 복원 라이브러리가 있습니다. 반면에 서비스 메시는 인프라 수준에서 복원력 패턴을 도입하는 옵션으로 존재합니다. 항상 그렇듯이 모든 경우에 적용되는 솔루션은 없으며 팀에서 가장 적합한 솔루션을 찾아야 합니다.