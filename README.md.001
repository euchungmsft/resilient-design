# resilient-design
App architecture design guide for resiliency - Retry, Fallback, Timeouts, Circuit Breakers

<https://blog.codecentric.de/en/2019/06/resilience-design-patterns-retry-fallback-timeout-circuit-breaker/>

## 도입

소프트웨어 복원력의 주요 목표는 해당 범위 내에서 결함을 허용할 수 있는 최대한의 구성을 이루는것. 자동 장애복구 (failover) 또는 이중화와 같은 방식으로 구성요소의 내결함성을 구현, 최근에는 상식으로 받아들여지는 경향 <WAF, ESLZ 링크, 설명>. 간단한 웹 애플리케이션에도 웹 서버, 데이터베이스, 방화벽, 프록시, 로드 밸런서 및 캐시 서버 등이 포함되고, 또한 네트워크 인프라는 너무 많은 구성 요소로 구성되어 항상 어딘가에서 오류가 발생함. 전체실패시나리오/SPoF 외에도 서비스 응답시간의 지체도 고려, 응답 형식이 정확하더라도 응답의 의미상의 오류를 발생하기도 함. 더 많은 구성 요소를 포함할 수록 실패 가능성은 상승함

### 가용성

가용성은 구성요소 서비스의 중요 품질속성으로 간주됨. 구성요소 서비스의 전체시간 대비 실제로 사용할 수 있는 시간으로 산정함

가용성 = 업타임 / (전체시간 = 업타임 + 다운타임)

### 직렬배치 vs 병렬배치
시스템을 직렬 및 병렬의 부품 상호 연결로 모델링하여 계산됩니다
https://www.eventhelix.com/fault-handling/system-reliability-availability/

- 부품의 고장으로 인해 조합이 작동하지 않는 경우 두 부품은 직렬로 작동하는 것으로 간주됩니다.
- 한 부품의 고장으로 인해 다른 부품이 고장난 부품의 작업을 대신하게 되면 두 부품은 병렬로 작동하는 것으로 간주됩니다.

#### 직렬배치 가용성

위에서 언급한 바와 같이 두 부품 X와 Y는 부품 중 하나의 고장으로 인해 조합의 고장이 발생하는 경우 직렬로 작동하는 것으로 간주됩니다. 결합된 시스템은 파트 X와 파트 Y를 모두 사용할 수 있는 경우에만 작동합니다. 이로부터 결합된 가용성은 두 부분의 가용성의 산물임을 알 수 있습니다. 결합된 가용성은 아래 방정식으로 표시됩니다.

https://www.eventhelix.com/fault-handling/availability_series.gif

A = Ax x Ay

#### 병렬배치 가용성

위에서 언급했듯이 두 부품이 모두 고장났을 때 결합이 실패한 것으로 간주되면 두 부품이 병렬로 작동하는 것으로 간주됩니다. 둘 중 하나를 사용할 수 있는 경우 결합된 시스템이 작동합니다. 이로부터 결합된 가용성은 1 -(두 부분 모두 사용할 수 없음)이 됩니다. 결합된 가용성은 아래 방정식으로 표시됩니다.

A = 1-(1-Ax)2

위 방정식의 의미는 병렬로 연결된 두 구성 요소의 가용성이 개별 구성 요소의 가용성보다 항상 훨씬 높다는 것입니다. 위 그림의 시스템을 고려하십시오. 파트 X의 두 인스턴스가 병렬로 연결됩니다. 아래 표는 개별 구성 요소와 병렬 조합의 가용성과 가동 중지 시간을 보여줍니다.


전통적인 접근 방식은 업타임을 늘리는 것을 목표로 하는 반면 현대적인 접근 방식은 복구시간을 줄여 다운타임을 줄이는 것을 목표로함. Uwe Friedrichsen 은 탄력성 설계 패턴을 느슨한결합, 격리, 대기시간 제어 및 감독 네 가지 범주로 분류

https://res.cloudinary.com/practicaldev/image/fetch/s--0IP86XgP--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/qstzssj2v491i412pkss.png

이 블로그 게시물에서는 대기 시간 제어 범주에서 Retry ,  fallback ,  timeout 및  circuit breaker 의 네 가지 패턴을 살펴보고자  합니다. 이론적 소개 후에 우리는 이러한 패턴이 Eclipse Vert.x를 사용하여 실제로 어떻게 적용될 수 있는지 볼 것입니다. 대체 구현에 대해 논의하고 결과를 요약하여 게시물을 마무리합니다.

## 패턴 

### Retry 

예상치 못한 응답(또는 해당 문제에 대한 응답 없음)이 요청을 다시 전송하여 수정할 수 있다고 가정할 때마다 재시도 패턴을 사용하는 것이 도움이 될 수 있습니다. 작업이 실패로 표시되기 전에 실패한 경우 실패한 요청이 구성 가능한 횟수만큼 재시도되는 매우 간단한 패턴입니다.

다음 애니메이션은 사기 수표 발행을 시도하는 결제 서비스를 보여줍니다. 첫 번째 요청은 부정행위 체크 서비스의 내부 서버 오류로 인해 실패합니다. 결제 서비스는 요청을 재시도하고 거래가 사기가 아니라는 응답을 받습니다.

https://res.cloudinary.com/practicaldev/image/fetch/s--UD_Gry29--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/o00e224x9qf4g100kcax.gif

재시도는 다음과 같은 경우에 유용할 수 있습니다.

패킷 손실과 같은 일시적인 네트워크 문제
대상 서비스의 내부 오류(예: 데이터베이스 중단으로 인한)
대상 서비스에 대한 많은 요청으로 인해 응답이 없거나 느린 경우
그러나 대상 서비스에 과부하가 걸려 문제가 발생한 경우 재시도하면 문제가 더욱 악화될 수 있습니다. 복원 패턴이 서비스 거부 공격으로 바뀌는 것을 방지하기 위해 재시도를 지수 백오프 또는 회로 차단기와 같은 다른 기술과 결합할 수 있습니다(아래 참조).

### Fallback

대체 패턴을 사용하면 다른 서비스에 대한 요청이 실패한 경우 서비스가 계속 실행될 수 있습니다. 응답 누락으로 인해 계산을 중단하는 대신 대체 값을 채웁니다.

다음 애니메이션은 사기 수표 서비스에 요청을 발행하는 결제 서비스를 다시 보여줍니다. 다시 말하지만, 사기 수표 서비스는 내부 서버 오류를 반환합니다. 그러나 이번에는 거래가 사기가 아니라고 가정하는 대체가 있습니다.

https://res.cloudinary.com/practicaldev/image/fetch/s--MRhfRPLU--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/7oxihrr3n5k67h5h4szb.gif

대체 값이 항상 가능한 것은 아니지만 신중하게 사용하면 전반적인 복원력을 크게 높일 수 있습니다. 위의 예에서 사기 수표 서비스를 사용할 수 없는 경우 거래를 사기가 아닌 것으로 처리하는 것으로 대체하는 것은 위험할 수 있습니다. 심지어 서비스에 스팸을 먼저 보낸 다음 사기 거래를 하려고 시도하는 사기 거래에 대한 공격 표면을 엽니다.

반면에 모든 거래가 사기라고 가정하면 대체가 이루어지지 않으며 대체는 본질적으로 쓸모가 없습니다. 좋은 절충안은 단순한 비즈니스 규칙으로 대체하는 것입니다. 예를 들어 위험과 고객을 잃지 않는 것 사이에서 균형을 잘 잡기 위해 합리적으로 적은 양의 거래를 단순히 허용하는 것입니다.

### Timeouts

시간 초과 패턴은 매우 간단하며 많은 HTTP 클라이언트에는 기본 시간 초과가 구성되어 있습니다. 목표는 응답에 대한 무한한 대기 시간을 피하여 제한 시간 내에 응답이 수신되지 않은 모든 요청을 실패한 것으로 처리하는 것입니다.

아래 애니메이션은 결제 서비스가 사기 수표 서비스의 응답을 기다리고 제한 시간을 초과한 후 작업을 중단하는 것을 보여줍니다.

https://res.cloudinary.com/practicaldev/image/fetch/s--29ERQzjI--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/e0eetjip5m311u9ofpzr.gif

시간 초과는 요청이 영원히 멈추는 것을 방지하기 위해 거의 모든 애플리케이션에서 사용됩니다. 그러나 시간 초과를 처리하는 것은 쉬운 일이 아닙니다. 온라인 상점에서 주문 시간이 초과되었다고 상상해 보십시오. 주문이 성공적으로 접수되었는지 확신할 수 없지만 주문 생성이 아직 진행 중이거나 요청이 처리되지 않은 경우 응답 시간이 초과되었습니다. 시간 초과를 재시도와 결합하면 중복 주문이 발생할 수 있습니다. 주문을 실패로 표시하면 고객은 주문이 성공하지 못했다고 생각할 수 있지만 성공했을 수도 있고 청구될 것입니다.

또한 더 느린 응답이 도착할 수 있을 만큼 충분히 높지만 결코 도착하지 않을 응답을 기다리지 않을 만큼 충분히 낮은 시간 초과를 원합니다.

### Circuit breaker

전자 제품에서 회로 차단기는 과부하로 인한 손상으로부터 구성 요소를 보호하는 스위치입니다. 소프트웨어에서 회로 차단기는 높은 부하로 인해 이미 부분적으로 사용할 수 없는 동안 스팸이 발생하지 않도록 서비스를 보호합니다.

차단기  패턴 마틴 파울러하여 설명 하였다. 닫힘(요청이 자유롭게 흐를 수 있음), 열림(요청이 원격 리소스에 제출되지 않고 거부됨) 및 반개방(하나의 프로브 요청이 회로를 다시 닫으십시오). 아래 애니메이션은 작동 중인 회로 차단기를 보여줍니다.

https://res.cloudinary.com/practicaldev/image/fetch/s--27Vzd1lb--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/u3f6z484i74k0osz5r6z.gif


결제 서비스에서 사기 수표 서비스로의 요청은 회로 차단기를 통해 전달됩니다. 두 개의 내부 서버 오류가 발생한 후 회로가 열리고 후속 요청이 차단됩니다. 약간의 대기 시간 후에 회로는 반개방 상태가 됩니다. 이 상태에서는 하나의 요청을 통과하고 실패할 경우 열린 상태로 다시 변경하거나 성공할 경우 닫힌 상태로 변경할 수 있습니다. 다음 요청이 성공하여 회로가 다시 닫힙니다.

회로 차단기는 특히 재시도, 시간 초과 및 대체와 결합될 때 유용한 도구입니다. 폴백은 장애가 발생한 경우뿐만 아니라 회로가 열려 있는 경우에도 사용할 수 있습니다. 다음 섹션에서는 Kotlin으로 작성된 Vert.x의 코드 예제를 살펴보겠습니다.

## 정리하기

이 게시물에서 우리는 느슨한 결합, 격리, 대기 시간 제어 및 감독이 시스템 복원력에 긍정적인 영향을 미칠 수 있는 방법을 보았습니다. 재시도 패턴을 사용하면 여러 번 시도하여 수정할 수 있는 통신 오류를 처리할 수 있습니다. 대체 패턴은 로컬에서 통신 오류를 해결하는 데 도움이 됩니다. 시간 초과 패턴은 대기 시간의 상한을 제공합니다. 회로 차단기는 통신 오류가 지속되는 경우 재시도 및 빠른 폴백으로 인한 우발적인 서비스 거부 공격 문제를 해결합니다.

Vert.x와 같은 프레임워크는 기본적으로 몇 가지 복원 패턴을 제공합니다. 또한 모든 프레임워크와 함께 사용할 수 있는 전용 복원 라이브러리가 있습니다. 반면에 서비스 메시는 인프라 수준에서 복원력 패턴을 도입하는 옵션으로 존재합니다. 항상 그렇듯이 모든 경우에 적용되는 솔루션은 없으며 팀에서 가장 적합한 솔루션을 찾아야 합니다.